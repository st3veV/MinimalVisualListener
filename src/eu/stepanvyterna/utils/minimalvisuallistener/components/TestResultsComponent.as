/**
 * TestResultsComponent.as
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Stepan Vyterna
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package eu.stepanvyterna.utils.minimalvisuallistener.components
{
	import com.bit101.components.Accordion;
	import com.bit101.components.Label;
	import com.bit101.components.List;
	import com.bit101.components.Panel;
	import com.bit101.components.ScrollPane;
	import com.bit101.components.Style;
	import com.bit101.components.Window;

	import eu.stepanvyterna.utils.minimalvisuallistener.data.TestElement;
	import eu.stepanvyterna.utils.minimalvisuallistener.data.TestSuiteElement;
	import eu.stepanvyterna.utils.minimalvisuallistener.data.TestSuiteElementStats;

	import flash.display.DisplayObjectContainer;
	import flash.text.TextField;
	import flash.text.TextFormat;

	public class TestResultsComponent extends ScrollPane
	{

		public static const COLOR_PASS:uint = 0x009f00;
		public static const COLOR_IGNORE:uint = 0xff7f00;
		public static const COLOR_FAIL:uint = 0xff0000;

		private static const LABEL_NAME:String = "label";
		private static const STATS_NAME:String = "stats";
		private static const SCROLLBAR_WIDTH:Number = 10;
		private static const SCROLLBAR_HEIGHT:Number = 10;
		private static const WINDOW_HEADER_HEIGHT:Number = 20;
		private static const HEADER_STATS_RIGHT_OFFSET:Number = 5;

		private var passTextFormat:TextFormat = new TextFormat( Style.fontName, Style.fontSize, COLOR_PASS, true );   //Green text
		private var ignoreTextFormat:TextFormat = new TextFormat( Style.fontName, Style.fontSize, COLOR_IGNORE, true ); //Orange text
		private var failTextFormat:TextFormat = new TextFormat( Style.fontName, Style.fontSize, COLOR_FAIL, true );   //Red text

		private var tests:Accordion;
		private var _testSuites:Vector.<TestSuiteElement>;
		private var lists:Vector.<List> = new Vector.<List>();


		public function TestResultsComponent( parent:DisplayObjectContainer = null, xpos:Number = 0, ypos:Number = 0 )
		{
			super( parent, xpos, ypos );
			init();
		}

		private function init():void
		{
			tests = new Accordion( this.content );
			tests.setSize( width - SCROLLBAR_WIDTH, height - SCROLLBAR_HEIGHT );
			tests.draw();
		}

		override public function setSize( w:Number, h:Number ):void
		{
			super.setSize( w, h );
			if ( tests )
			{
				tests.setSize( w - SCROLLBAR_WIDTH, h - SCROLLBAR_HEIGHT );
				tests.draw();
			}
		}

		public function initialize( testSuites:Vector.<TestSuiteElement> ):void
		{
			_testSuites = testSuites;

			var i:int;
			var win:Window;
			for ( i = 0; i < 2; i++ ) // replacing existing windows generated by Accordion
			{
				win = tests.getWindowAt( i );
				win.title = _testSuites[ i ].name;
				win.draw();
				adjustHeader( win.titleBar );
				generateTestContent( _testSuites[ i ], win );
			}
			for ( ; i < _testSuites.length; i++ )
			{
				tests.addWindow( _testSuites[ i ].name );
				win = tests.getWindowAt( i );
				win.draw();
				adjustHeader( win.titleBar );
				generateTestContent( _testSuites[ i ], win );
			}
			tests.height = Math.max( _height - SCROLLBAR_HEIGHT, i * WINDOW_HEADER_HEIGHT );
			for ( var j:int = 0; j < lists.length; j++ )
			{
				const list:List = lists[ j ];
				list.height = tests.height - i * WINDOW_HEADER_HEIGHT;
				list.width = tests.width;
				list.draw();
			}

			refresh();
		}

		private function generateTestContent( testSuiteElement:TestSuiteElement, window:Window ):void
		{
			var items:Array = [];
			for ( var i:int = 0; i < testSuiteElement.testElements.length; i++ )
			{
				var testElement:TestElement = testSuiteElement.testElements[ i ];
				items.push( testElement );
			}
			const list:List = new List( window, 0, 0, items );
			list.listItemClass = TestResultListItem;
			lists.push( list )
		}


		public function refresh():void
		{
			draw();
			invalidate();
		}


		override public function draw():void
		{
			super.draw();

			tests.draw();

			if ( !_testSuites )
			{
				return;
			}
			var stats:TestSuiteElementStats;
			var win:Window;
			var suiteElement:TestSuiteElement;
			for ( var i:int = 0; i < _testSuites.length; i++ )
			{
				suiteElement = _testSuites[ i ];
				if ( suiteElement.dirty )
				{
					win = tests.getWindowAt( i );
					stats = suiteElement.getStats();
					win.titleBar.draw();
					adjustHeader( win.titleBar, stats );
					suiteElement.dirty = false;
					lists[ i ].draw();
				}
			}
		}

		private function adjustHeader( header:Panel, stats:TestSuiteElementStats = null ):void
		{
			var statsLabel:Label;
			var label:Label;
			if ( (label = header.content.getChildByName( LABEL_NAME ) as Label) != null )
			{
				statsLabel = header.content.getChildByName( STATS_NAME ) as Label;
			}
			else
			{
				var i:int = 0;
				while ( label == null )
				{
					label = header.content.getChildAt( i++ ) as Label;
				}
				label.name = LABEL_NAME;
				statsLabel = new Label( header.content, 0, 1, "0:0:0/0" );
				statsLabel.name = STATS_NAME;
				statsLabel.textField.x = header.width - statsLabel.textField.width - HEADER_STATS_RIGHT_OFFSET;
			}
			if ( !stats )
			{
				return;
			}
			var txt:TextField = statsLabel.textField;
			statsLabel.text = stats.toString();
			statsLabel.draw();

			var fromIndex:int = 0;
			var toIndex:int = txt.text.indexOf( ":", fromIndex );
			txt.setTextFormat( passTextFormat, fromIndex, toIndex );
			fromIndex = toIndex + 1;
			toIndex = txt.text.indexOf( ":", fromIndex );
			txt.setTextFormat( ignoreTextFormat, fromIndex, toIndex );
			fromIndex = toIndex + 1;
			toIndex = txt.text.indexOf( "/", fromIndex );
			txt.setTextFormat( failTextFormat, fromIndex, toIndex );

			txt.x = _width - txt.width - HEADER_STATS_RIGHT_OFFSET - SCROLLBAR_WIDTH;
		}
	}
}
